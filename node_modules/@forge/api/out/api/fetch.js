"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandboxRuntimeAPI = exports.getNodeRuntimeAPI = exports.addMagicAgent = exports.fetchRemote = exports.fetchProduct = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const _1 = require(".");
const runtime_1 = require("./runtime");
const polyfill_response_1 = require("./polyfill-response");
const errors_1 = require("./errors");
function fetchProduct(args) {
    return async (path, init) => {
        const url = productURL(args.remote, path);
        init = (0, exports.addMagicAgent)(init);
        init.headers = Object.assign(Object.assign({}, init.headers), { authorization: `Forge ${args.provider}` });
        const response = await (0, node_fetch_1.default)(url, init);
        handleProxyResponseErrors(response);
        return response;
    };
}
exports.fetchProduct = fetchProduct;
function fetchRemote(args) {
    return async (path, init) => {
        const url = `https://${args.remote}${path}`;
        init = (0, exports.addMagicAgent)(init, 'EXTERNAL_AUTH_REQUEST');
        init.headers = Object.assign(Object.assign({}, init.headers), { authorization: `Forge user ${args.provider} ${args.account}` });
        const response = await (0, node_fetch_1.default)(url, init);
        handleProxyResponseErrors(response);
        return response;
    };
}
exports.fetchRemote = fetchRemote;
function getDefaultRemote(provider) {
    const externalAuthProvider = findExternalAuthProviderConfigOrThrow(provider);
    if (!externalAuthProvider.remotes.length) {
        throw new Error(`Missing remote config for provider ${provider}`);
    }
    return externalAuthProvider.remotes[0].key;
}
function findExternalAuthProviderConfigOrThrow(provider) {
    const { externalAuth } = (0, runtime_1.__getRuntime)();
    const externalAuthProvider = externalAuth === null || externalAuth === void 0 ? void 0 : externalAuth.find((externalAuthMetaData) => {
        return externalAuthMetaData.service === provider;
    });
    if (!externalAuthProvider) {
        throw new Error(`Bad provider or missing config for provider ${provider}`);
    }
    return externalAuthProvider;
}
const ATLASSIAN_TOKEN_SERVICE_KEY = 'atlassian-token-service-key';
const handleProxyResponseErrors = (response) => {
    if (response.headers.has('forge-proxy-error')) {
        const errorReason = response.headers.get('forge-proxy-error');
        if (errorReason === 'NEEDS_AUTHENTICATION_ERR') {
            throw new errors_1.NeedsAuthenticationError('Authentication Required', ATLASSIAN_TOKEN_SERVICE_KEY);
        }
        throw new errors_1.ProxyRequestError(response.status, response.headers.get('forge-proxy-error'));
    }
};
function productURL(remote, path) {
    if (!path.startsWith('/')) {
        path = '/' + path;
    }
    return `https://${remote}${path}`;
}
function lazyThrowNeedsAuthenticationError(serviceKey) {
    return async (scopes) => {
        throw new errors_1.NeedsAuthenticationError('Authentication Required', serviceKey, scopes && { scopes });
    };
}
function buildExternalAuthAccountsInfo(provider, remote) {
    const { accounts } = findExternalAuthProviderConfigOrThrow(provider);
    const buildAccountModel = (account) => {
        const { externalAccountId: id } = account, rest = tslib_1.__rest(account, ["externalAccountId"]);
        return Object.assign(Object.assign({}, rest), { id });
    };
    const buildExternalAuthAccountMethods = (account, outboundAuthAccountId) => ({
        hasCredentials: async (scopes) => !scopes || scopes.every((scope) => account.scopes.includes(scope)),
        requestCredentials: lazyThrowNeedsAuthenticationError(provider),
        getAccount: async () => {
            return account;
        },
        fetch: (0, _1.wrapWithRouteUnwrapper)(fetchRemote({ provider, remote: remote !== null && remote !== void 0 ? remote : getDefaultRemote(provider), account: outboundAuthAccountId }))
    });
    return accounts.map((account) => {
        const authAccount = buildAccountModel(account);
        return {
            account: authAccount,
            methods: buildExternalAuthAccountMethods(authAccount, account.id)
        };
    });
}
const addMagicAgent = (init, agentOverride) => (Object.assign(Object.assign({}, init), { agent: (agentOverride !== null && agentOverride !== void 0 ? agentOverride : 'FORGE_PRODUCT_REQUEST') }));
exports.addMagicAgent = addMagicAgent;
const throwNotImplementedError = () => {
    throw new Error('not implemented');
};
const withProvider = (provider, remote) => {
    const accountsInfo = buildExternalAuthAccountsInfo(provider, remote);
    const defaultAccountInfo = accountsInfo.length ? accountsInfo[0] : undefined;
    const lazyThrowNoValidCredentialsError = () => {
        return (url) => {
            throw new Error(`Fetch failed for ${remote ? `remote '${remote}', ` : ''}provider '${provider}', path '${url}' no credentials previously requested`);
        };
    };
    return {
        hasCredentials: async (scopes) => {
            return defaultAccountInfo ? await defaultAccountInfo.methods.hasCredentials(scopes) : false;
        },
        getAccount: async () => {
            return defaultAccountInfo ? defaultAccountInfo.account : undefined;
        },
        requestCredentials: lazyThrowNeedsAuthenticationError(provider),
        listCredentials: throwNotImplementedError,
        listAccounts: async () => {
            return accountsInfo.map(({ account }) => account);
        },
        asAccount: (externalAccountId) => {
            const accountInfo = accountsInfo.find(({ account }) => account.id === externalAccountId);
            if (!accountInfo) {
                throw new Error(`No account with ID ${externalAccountId} found for provider ${provider}`);
            }
            return accountInfo.methods;
        },
        fetch: defaultAccountInfo ? defaultAccountInfo.methods.fetch : lazyThrowNoValidCredentialsError()
    };
};
function getNodeRuntimeAPI() {
    return {
        fetch: (0, _1.wrapWithRouteUnwrapper)(node_fetch_1.default),
        requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'jira' })),
        requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'confluence' })),
        requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'bitbucket' })),
        asUser: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'user', remote: 'stargate' })),
            requestConnectedData: (0, _1.wrapRequestConnectedData)(fetchProduct({ provider: 'user', remote: 'stargate' })),
            withProvider
        }),
        asApp: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'app', remote: 'stargate' })),
            requestConnectedData: (0, _1.wrapRequestConnectedData)(fetchProduct({ provider: 'app', remote: 'stargate' }))
        })
    };
}
exports.getNodeRuntimeAPI = getNodeRuntimeAPI;
function getSandboxRuntimeAPI(api) {
    return (0, _1.wrapFetchApiMethods)(api, polyfill_response_1.transformResponse);
}
exports.getSandboxRuntimeAPI = getSandboxRuntimeAPI;
